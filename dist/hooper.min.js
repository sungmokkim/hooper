var t, i;
(t = this),
  (i = function(t, i) {
    'use strict';
    function c(t, i, e) {
      return (
        i in t ? Object.defineProperty(t, i, { value: e, enumerable: !0, configurable: !0, writable: !0 }) : (t[i] = e),
        t
      );
    }
    function n(i, t) {
      var e = Object.keys(i);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(i);
        t &&
          (n = n.filter(function(t) {
            return Object.getOwnPropertyDescriptor(i, t).enumerable;
          })),
          e.push.apply(e, n);
      }
      return e;
    }
    function h(i) {
      for (var t = 1; t < arguments.length; t++) {
        var e = null != arguments[t] ? arguments[t] : {};
        t % 2
          ? n(e, !0).forEach(function(t) {
              c(i, t, e[t]);
            })
          : Object.getOwnPropertyDescriptors
          ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(e))
          : n(e).forEach(function(t) {
              Object.defineProperty(i, t, Object.getOwnPropertyDescriptor(e, t));
            });
      }
      return i;
    }
    function l(t) {
      return (
        (function(t) {
          if (Array.isArray(t)) {
            for (var i = 0, e = new Array(t.length); i < t.length; i++) e[i] = t[i];
            return e;
          }
        })(t) ||
        (function(t) {
          if (Symbol.iterator in Object(t) || '[object Arguments]' === Object.prototype.toString.call(t))
            return Array.from(t);
        })(t) ||
        (function() {
          throw new TypeError('Invalid attempt to spread non-iterable instance');
        })()
      );
    }
    function r() {
      return Date.now();
    }
    function e(e, n) {
      (this.create = function() {
        return window.setTimeout(e, n);
      }),
        (this.stop = function() {
          this.timer && (window.clearTimeout(this.timer), (this.timer = null));
        }),
        (this.start = function() {
          this.timer || (this.timer = this.create());
        }),
        (this.set = function(t) {
          var i = t || n;
          this.timer = window.setTimeout(e, i);
        }),
        (this.timer = this.create());
    }
    function u(t, i) {
      var e;
      return (e = t < 0 ? (t + i) % i : t % i) != e ? 0 : e;
    }
    function d(t, i) {
      var e = i.children || i.componentOptions.children || i.text;
      return t(i.componentOptions.Ctor, i.data, e);
    }
    i = i && i.hasOwnProperty('default') ? i.default : i;
    var o =
      Object.assign ||
      function(t) {
        if (null == t) throw new TypeError('Cannot convert first argument to object');
        for (var i = Object(t), e = 1; e < arguments.length; e++) {
          var n = arguments[e];
          if (null != n) {
            n = Object(n);
            for (var r = Object.keys(Object(n)), o = 0, s = r.length; o < s; o++) {
              var a = r[o],
                h = Object.getOwnPropertyDescriptor(n, a);
              void 0 !== h && h.enumerable && (i[a] = n[a]);
            }
          }
        }
        return i;
      };
    var s =
      Math.sign ||
      function(t) {
        return t < 0 ? -1 : 0 < t ? 1 : 0;
      };
    function p(t, i) {
      var e = 1 < arguments.length && void 0 !== i ? i : {};
      return t.$scopedSlots.default ? t.$scopedSlots.default(e) || [] : t.$slots.default || [];
    }
    var f = new i(),
      a = {
        name: 'Hooper',
        provide: function() {
          return { $hooper: this };
        },
        props: {
          itemsToShow: { default: 1, type: Number },
          itemsToSlide: { default: 1, type: Number },
          initialSlide: { default: 0, type: Number },
          infiniteScroll: { default: !1, type: Boolean },
          centerMode: { default: !1, type: Boolean },
          vertical: { default: !1, type: Boolean },
          rtl: { default: null, type: Boolean },
          autoPlay: { default: !1, type: Boolean },
          playSpeed: { default: 2e3, type: Number },
          mouseDrag: { default: !0, type: Boolean },
          touchDrag: { default: !0, type: Boolean },
          wheelControl: { default: !0, type: Boolean },
          keysControl: { default: !0, type: Boolean },
          shortDrag: { default: !0, type: Boolean },
          transition: { default: 300, type: Number },
          hoverPause: { default: !0, type: Boolean },
          trimWhiteSpace: { default: !1, type: Boolean },
          settings: {
            default: function() {
              return {};
            },
            type: Object
          },
          group: { type: String, default: null },
          horizontalMargin: { default: 0, type: Number },
          numberBeforeOnLastItem: { default: 1, type: Number },
          fadeInOut: { type: Boolean, default: !1 },
          customTrimEnd: { type: Number, default: 0 }
        },
        data: function() {
          return {
            isDragging: !1,
            isSliding: !1,
            isTouch: !1,
            isHover: !1,
            isFocus: !1,
            initialized: !1,
            slideWidth: 0,
            slideHeight: 0,
            slidesCount: 0,
            trimStart: 0,
            trimEnd: 1,
            currentSlide: null,
            timer: null,
            defaults: {},
            breakpoints: {},
            delta: { x: 0, y: 0 },
            config: {}
          };
        },
        computed: {
          slideBounds: function() {
            var t = this.config,
              i = this.currentSlide,
              e = t.itemsToShow;
            return {
              lower: t.centerMode ? Math.ceil(i - e / 2) : i,
              upper: t.centerMode ? Math.floor(i + e / 2) : Math.floor(i + e - 1)
            };
          },
          trackTransform: function() {
            var t = this.config,
              i = t.infiniteScroll,
              e = t.vertical,
              n = t.rtl,
              r = t.centerMode,
              o = n ? -1 : 1,
              s = e ? this.slideHeight : this.slideWidth,
              a = e ? this.containerHeight : this.containerWidth,
              h =
                (e ? this.delta.y : this.delta.x) +
                o * ((r ? (a - s) / 2 : 0) - (i ? s * this.slidesCount : 0) - this.currentSlide * s);
            if (e) return 'transform: translate(0, '.concat(h, 'px);');
            var u = this.slideBounds.upper === this.slidesCount - 1,
              c = this.slidesCount >= this.config.itemsToShow;
            return 'transform: translate('.concat(u && c ? h : h + this.config.horizontalMargin, 'px, 0);');
          },
          trackTransition: function() {
            return this.initialized && this.isSliding ? 'transition: '.concat(this.config.transition, 'ms') : '';
          }
        },
        watch: {
          group: function(t, i) {
            t !== i && (f.$off('slideGroup:'.concat(i), this._groupSlideHandler), this.addGroupListeners());
          },
          autoPlay: function(t, i) {
            t !== i && this.restartTimer();
          }
        },
        methods: {
          slideTo: function(t, i) {
            var e = this,
              n = !(1 < arguments.length && void 0 !== i) || i;
            if (!this.isSliding && t !== this.currentSlide) {
              this.$emit('beforeSlide', { currentSlide: this.currentSlide, slideTo: h });
              var r = this.config,
                o = r.infiniteScroll,
                s = r.transition,
                a = this.currentSlide,
                h = o
                  ? t
                  : (function(t, i, e) {
                      return Math.max(Math.min(t, e), i);
                    })(t, this.trimStart, this.slidesCount - this.trimEnd);
              this.group && n && f.$emit('slideGroup:'.concat(this.group), t),
                (this.currentSlide = h),
                (this.isSliding = !0),
                window.setTimeout(function() {
                  (e.isSliding = !1),
                    (e.currentSlide = u(h, e.slidesCount)),
                    e.$emit('afterSlide', { currentSlide: e.currentSlide });
                }, s),
                this.$emit('slide', { currentSlide: this.currentSlide, slideFrom: a }),
                this.slideBounds.upper === this.slidesCount - this.config.numberBeforeOnLastItem &&
                  this.$emit('onLastItem', { currentSlide: this.currentSlide, slideFrom: a });
            }
          },
          slideNext: function() {
            this.slideTo(this.currentSlide + this.config.itemsToSlide);
          },
          slidePrev: function() {
            this.slideTo(this.currentSlide - this.config.itemsToSlide);
          },
          initEvents: function() {
            null === this.defaults.rtl && (this.defaults.rtl = 'rtl' === getComputedStyle(this.$el).direction),
              this.$props.autoPlay && this.initAutoPlay(),
              this.config.mouseDrag && this.$refs.list.addEventListener('mousedown', this.onDragStart),
              this.config.touchDrag &&
                this.$refs.list.addEventListener('touchstart', this.onDragStart, { passive: !0 }),
              this.config.keysControl && this.$el.addEventListener('keydown', this.onKeypress),
              this.config.wheelControl &&
                ((this.lastScrollTime = r()), this.$el.addEventListener('wheel', this.onWheel, { passive: !1 })),
              window.addEventListener('resize', this.update);
          },
          getCurrentSlideTimeout: function() {
            var t = u(this.currentSlide, this.slidesCount);
            return p(this)[t].componentOptions.propsData.duration;
          },
          initAutoPlay: function() {
            var t = this;
            this.timer = new e(function() {
              if (t.isSliding || t.isDragging || (t.isHover && t.config.hoverPause) || t.isFocus || !t.$props.autoPlay)
                t.timer.set(t.getCurrentSlideTimeout());
              else {
                if (t.currentSlide === t.slidesCount - 1 && !t.config.infiniteScroll)
                  return t.slideTo(0), void t.timer.set(t.getCurrentSlideTimeout());
                t.slideNext(), t.timer.set(t.getCurrentSlideTimeout());
              }
            }, this.getCurrentSlideTimeout());
          },
          initDefaults: function() {
            (this.breakpoints = this.settings.breakpoints),
              (this.defaults = o({}, this.$props, this.settings)),
              (this.config = o({}, this.defaults));
          },
          update: function() {
            this.breakpoints && this.updateConfig(),
              this.updateWidth(),
              this.updateTrim(),
              this.$emit('updated', {
                containerWidth: this.containerWidth,
                containerHeight: this.containerHeight,
                slideWidth: this.slideWidth,
                slideHeight: this.slideHeight,
                settings: this.config
              });
          },
          updateTrim: function() {
            var t = this.config,
              i = t.trimWhiteSpace,
              e = t.itemsToShow,
              n = t.centerMode,
              r = t.infiniteScroll,
              o = t.customTrimEnd;
            if (!i || r) return (this.trimStart = 0), void (this.trimEnd = 1);
            (this.trimStart = n ? Math.floor((e - 1) / 2) : 0), (this.trimEnd = o || (n ? Math.ceil(e / 2) : e));
          },
          updateWidth: function() {
            var t = this.$el.getBoundingClientRect();
            (this.containerWidth = t.width),
              (this.containerHeight = t.height),
              this.config.vertical
                ? (this.slideHeight = this.containerHeight / this.config.itemsToShow)
                : ((this.slideWidth = this.containerWidth / this.config.itemsToShow),
                  (this.containerWidth = this.containerWidth + 2 * this.config.horizontalMargin));
          },
          updateConfig: function() {
            var i,
              e = this;
            Object.keys(this.breakpoints)
              .sort(function(t, i) {
                return i - t;
              })
              .some(function(t) {
                if ((i = window.matchMedia('(min-width: '.concat(t, 'px)')).matches))
                  return (e.config = o({}, e.config, e.defaults, e.breakpoints[t])), !0;
              }),
              i || (this.config = o(this.config, this.defaults));
          },
          restartTimer: function() {
            var t = this;
            this.$nextTick(function() {
              null === t.timer && t.$props.autoPlay
                ? t.initAutoPlay()
                : t.timer &&
                  (t.timer.stop(), t.$props.autoPlay && (t.timer.set(t.getCurrentSlideTimeout()), t.timer.start()));
            });
          },
          restart: function() {
            var t = this;
            this.$nextTick(function() {
              t.update();
            });
          },
          onDragStart: function(t) {
            (this.isTouch = 'touchstart' === t.type),
              (!this.isTouch && 0 !== t.button) ||
                ((this.startPosition = { x: 0, y: 0 }),
                (this.endPosition = { x: 0, y: 0 }),
                (this.isDragging = !0),
                (this.startPosition.x = this.isTouch ? t.touches[0].clientX : t.clientX),
                (this.startPosition.y = this.isTouch ? t.touches[0].clientY : t.clientY),
                document.addEventListener(this.isTouch ? 'touchmove' : 'mousemove', this.onDrag),
                document.addEventListener(this.isTouch ? 'touchend' : 'mouseup', this.onDragEnd));
          },
          isInvalidDirection: function(t, i) {
            return this.config.vertical
              ? !!this.config.vertical && Math.abs(i) <= Math.abs(t)
              : Math.abs(t) <= Math.abs(i);
          },
          onDrag: function(t) {
            if (!this.isSliding) {
              (this.endPosition.x = this.isTouch ? t.touches[0].clientX : t.clientX),
                (this.endPosition.y = this.isTouch ? t.touches[0].clientY : t.clientY);
              var i = this.endPosition.x - this.startPosition.x,
                e = this.endPosition.y - this.startPosition.y;
              this.isInvalidDirection(i, e) ||
                ((this.delta.y = e), (this.delta.x = i), this.isTouch || t.preventDefault());
            }
          },
          onDragEnd: function() {
            var t = this.config.shortDrag ? 0.5 : 0.15;
            if (((this.isDragging = !1), this.config.vertical)) {
              var i = Math.round(Math.abs(this.delta.y / this.slideHeight) + t);
              this.slideTo(this.currentSlide - s(this.delta.y) * i);
            }
            if (!this.config.vertical) {
              var e = (this.config.rtl ? -1 : 1) * s(this.delta.x),
                n = Math.round(Math.abs(this.delta.x / this.slideWidth) + t);
              this.slideTo(this.currentSlide - e * n);
            }
            (this.delta.x = 0),
              (this.delta.y = 0),
              document.removeEventListener(this.isTouch ? 'touchmove' : 'mousemove', this.onDrag),
              document.removeEventListener(this.isTouch ? 'touchend' : 'mouseup', this.onDragEnd),
              this.restartTimer();
          },
          onTransitionend: function() {},
          onKeypress: function(t) {
            var i = t.key;
            return (
              i.startsWith('Arrow') && t.preventDefault(),
              this.config.vertical
                ? ('ArrowUp' === i && this.slidePrev(), void ('ArrowDown' === i && this.slideNext()))
                : this.config.rtl
                ? ('ArrowRight' === i && this.slidePrev(), void ('ArrowLeft' === i && this.slideNext()))
                : ('ArrowRight' === i && this.slideNext(), void ('ArrowLeft' === i && this.slidePrev()))
            );
          },
          onWheel: function(t) {
            if ((t.preventDefault(), !(r() - this.lastScrollTime < 200))) {
              this.lastScrollTime = r();
              var i = t.wheelDelta || -t.deltaY,
                e = s(i);
              -1 === e && this.slideNext(), 1 === e && this.slidePrev();
            }
          },
          addGroupListeners: function() {
            var i = this;
            this.group &&
              ((this._groupSlideHandler = function(t) {
                i.slideTo(t, !1);
              }),
              f.$on('slideGroup:'.concat(this.group), this._groupSlideHandler));
          }
        },
        created: function() {
          this.initDefaults();
        },
        mounted: function() {
          var t = this;
          this.initEvents(),
            this.addGroupListeners(),
            this.$nextTick(function() {
              t.update(),
                t.slideTo(t.config.initialSlide || 0),
                setTimeout(function() {
                  t.$emit('loaded'), (t.initialized = !0);
                }, t.transition);
            });
        },
        beforeDestroy: function() {
          window.removeEventListener('resize', this.update),
            this.group && f.$off('slideGroup:'.concat(this.group), this._groupSlideHandler),
            this.timer && this.timer.stop();
        },
        render: function(t) {
          var i = this,
            e = function(t) {
              var i = function(t) {
                  for (var i = p(this), e = i.length, n = 0, r = [], o = 0; o < e; o++) {
                    var s = i[o],
                      a = s.componentOptions && s.componentOptions.Ctor;
                    a &&
                      'HooperSlide' === a.options.name &&
                      ((s.componentOptions.propsData.index = n),
                      (s.data.key = n),
                      (s.key = n),
                      (s.data.props = h({}, s.data.props || {}, { isClone: !1, index: n++ })),
                      r.push(s));
                  }
                  (this.slidesCount = r.length),
                    this.config.infiniteScroll &&
                      (r = (function(t, i) {
                        for (var e = [], n = [], r = i.length, o = 0; o < r; o++) {
                          var s = i[o],
                            a = d(t, s),
                            h = o - r;
                          (a.data.key = 'before_'.concat(o)),
                            (a.key = a.data.key),
                            (a.componentOptions.propsData.index = h),
                            (a.data.props = { index: h, isClone: !0 }),
                            e.push(a);
                          var u = d(t, s);
                          (h = o + r),
                            (u.data.key = 'after_'.concat(h)),
                            (u.componentOptions.propsData.index = h),
                            (u.key = u.data.key),
                            (u.data.props = { index: h, isClone: !0 }),
                            n.push(u);
                        }
                        return [].concat(e, l(i), n);
                      })(t, r));
                  return t(
                    'ul',
                    {
                      class: { 'hooper-track': !0, 'is-dragging': this.isDragging },
                      style: this.trackTransform + this.trackTransition,
                      ref: 'track',
                      on: { transitionend: this.onTransitionend }
                    },
                    r
                  );
                }.call(this, t),
                e = this.$slots['hooper-addons'] || [],
                n = t(
                  'div',
                  {
                    class: 'hooper-liveregion hooper-sr-only',
                    attrs: { 'aria-live': 'polite', 'aria-atomic': 'true' }
                  },
                  'Item '.concat(this.currentSlide + 1, ' of ').concat(this.slidesCount)
                ),
                r = [i].concat(l(e), [n]);
              return [t('div', { class: 'hooper-list', ref: 'list' }, r)];
            }.call(this, t);
          return t(
            'section',
            {
              class: { hooper: !0, 'is-vertical': this.config.vertical, 'is-rtl': this.config.rtl },
              attrs: { tabindex: '0' },
              on: {
                focusin: function() {
                  return (i.isFocus = !0);
                },
                focusout: function() {
                  return (i.isFocus = !1);
                },
                mouseover: function() {
                  return (i.isHover = !0);
                },
                mouseleave: function() {
                  return (i.isHover = !1);
                }
              }
            },
            e
          );
        }
      };
    var g = {
        name: 'HooperSlide',
        inject: ['$hooper'],
        props: {
          isClone: { type: Boolean, default: !1 },
          index: { type: Number, required: !0 },
          duration: { type: Number, default: null }
        },
        computed: {
          style: function() {
            var t = this.$hooper || {},
              i = t.config,
              e = t.slideHeight,
              n = t.slideWidth;
            return i.vertical ? 'height: '.concat(e, 'px;') : 'width: '.concat(n, 'px;');
          },
          isActive: function() {
            var t = this.$hooper.slideBounds,
              i = t.upper,
              e = t.lower;
            return this.index >= e && this.index <= i;
          },
          isPrev: function() {
            var t = this.$hooper.slideBounds.lower,
              i = this.$hooper.config.itemsToSlide;
            return this.index < t && this.index >= t - i;
          },
          isNext: function() {
            var t = this.$hooper.slideBounds.upper,
              i = this.$hooper.config.itemsToSlide;
            return this.index > t && this.index <= t + i;
          },
          isCurrent: function() {
            return this.index === this.$hooper.currentSlide;
          },
          transition: function() {
            var t = this.$hooper.config,
              i = t.fadeInOut,
              e = t.transition;
            return i ? 'transition: opacity '.concat(0.9 * e, 'ms ease-in-out;') : null;
          },
          opacity: function() {
            return this.$hooper.config.fadeInOut ? (this.isActive ? 'opacity: 1;' : 'opacity: 0;') : null;
          }
        },
        render: function(t) {
          var i = {
              'hooper-slide': !0,
              'is-clone': this.isClone,
              'is-active': this.isActive,
              'is-prev': this.isPrev,
              'is-next': this.isNext,
              'is-current': this.isCurrent
            },
            e = p(this);
          return t(
            'li',
            { class: i, style: this.style + this.transition + this.opacity, attrs: { 'aria-hidden': !this.isActive } },
            e
          );
        }
      },
      m = {
        arrowUp: 'M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z',
        arrowDown: 'M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z',
        arrowRight: 'M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z',
        arrowLeft: 'M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z'
      },
      v = {
        name: 'HooperIcon',
        functional: !0,
        inheritAttrs: !0,
        props: {
          name: {
            type: String,
            required: !0,
            validator: function(t) {
              return t in m;
            }
          }
        },
        render: function(t, i) {
          var e = i.props,
            n = m[e.name],
            r = [];
          return (
            r.push(
              t(
                'title',
                (function(t) {
                  return (t = t.replace(/([A-Z]+)/g, ' $1')).charAt(0).toUpperCase() + t.slice(1);
                })(e.name)
              )
            ),
            r.push(t('path', { attrs: { d: 'M0 0h24v24H0z', fill: 'none' } })),
            r.push(t('path', { attrs: { d: n } })),
            t(
              'svg',
              { attrs: { class: 'icon icon-'.concat(e.name), viewBox: '0 0 24 24', width: '24px', height: '24px' } },
              r
            )
          );
        }
      },
      y = {
        inject: ['$hooper'],
        name: 'HooperProgress',
        computed: {
          currentSlide: function() {
            return u(this.$hooper.currentSlide, this.$hooper.slidesCount);
          },
          progress: function() {
            var t = this.$hooper.slidesCount - this.$hooper.trimStart - this.$hooper.trimEnd;
            return (100 * (this.currentSlide - this.$hooper.trimStart)) / t;
          }
        },
        render: function(t) {
          return t('div', { class: 'hooper-progress' }, [
            t('div', { class: 'hooper-progress-inner', style: 'width: '.concat(this.progress, '%') })
          ]);
        }
      };
    function S(i, e, t, n) {
      for (
        var r = [],
          o = function(t) {
            r.push(
              (function(t, i, e, n) {
                return t('li', [
                  t(
                    'button',
                    { class: { 'hooper-indicator': !0, 'is-active': e }, on: { click: n }, attrs: { type: 'button' } },
                    [t('span', { class: 'hooper-sr-only' }, 'item '.concat(i))]
                  )
                ]);
              })(i, t, t === e, function() {
                return n(t);
              })
            );
          },
          s = 0;
        s < t;
        s++
      )
        o(s);
      return [i('ol', { class: 'hooper-indicators' }, r)];
    }
    var w = {
      inject: ['$hooper'],
      name: 'HooperPagination',
      props: { mode: { default: 'indicator', type: String } },
      computed: {
        currentSlide: function() {
          return u(this.$hooper.currentSlide, this.$hooper.slidesCount);
        },
        slides: function() {
          var t = this.$hooper.slides.map(function(t, i) {
            return i;
          });
          return t.slice(this.$hooper.trimStart, this.$hooper.slidesCount - this.$hooper.trimEnd + 1);
        }
      },
      render: function(t) {
        var i = this,
          e = this.$hooper.slidesCount,
          n =
            'indicator' === this.mode
              ? S(t, this.currentSlide, e, function(t) {
                  return i.$hooper.slideTo(t);
                })
              : (function(t, i, e) {
                  return [t('span', i + 1), t('span', '/'), t('span', e)];
                })(t, this.currentSlide, e);
        return t('div', { class: { 'hooper-pagination': !0, 'is-vertical': this.$hooper.config.vertical } }, n);
      }
    };
    function b(t, i, e, n, r, o) {
      var s,
        a = r.isVertical,
        h = r.isRTL,
        u =
          e && e.length
            ? e
            : [
                t(v, {
                  props: {
                    name: (function(t, i, e) {
                      return e
                        ? t
                          ? 'arrowUp'
                          : i
                          ? 'arrowRight'
                          : 'arrowLeft'
                        : t
                        ? 'arrowDown'
                        : i
                        ? 'arrowLeft'
                        : 'arrowRight';
                    })(a, h, n)
                  }
                })
              ];
      return t(
        'button',
        {
          class: ((s = {}), c(s, 'hooper-'.concat(n ? 'prev' : 'next'), !0), c(s, 'is-disabled', i), s),
          attrs: { type: 'button' },
          on: { click: o }
        },
        u
      );
    }
    var $,
      T,
      x = {
        inject: ['$hooper'],
        name: 'HooperNavigation',
        computed: {
          isPrevDisabled: function() {
            return !this.$hooper.config.infiniteScroll && 0 === this.$hooper.currentSlide;
          },
          isNextDisabled: function() {
            return (
              !this.$hooper.config.infiniteScroll &&
              (this.$hooper.config.trimWhiteSpace
                ? this.$hooper.currentSlide ===
                  this.$hooper.slidesCount - Math.min(this.$hooper.config.itemsToShow, this.$hooper.slidesCount)
                : this.$hooper.currentSlide === this.$hooper.slidesCount - 1)
            );
          }
        },
        methods: {
          slideNext: function() {
            this.$hooper.slideNext(), this.$hooper.restartTimer();
          },
          slidePrev: function() {
            this.$hooper.slidePrev(), this.$hooper.restartTimer();
          }
        },
        render: function(t) {
          var i = this,
            e = { isRTL: this.$hooper.config.rtl, isVertical: this.$hooper.config.vertical },
            n = [
              b(t, this.isPrevDisabled, this.$slots['hooper-prev'], !0, e, function() {
                return i.slidePrev();
              }),
              b(t, this.isNextDisabled, this.$slots['hooper-next'], !1, e, function() {
                return i.slideNext();
              })
            ];
          return t(
            'div',
            {
              class: {
                'hooper-navigation': !0,
                'is-vertical': this.$hooper.config.vertical,
                'is-rtl': this.$hooper.config.rtl
              }
            },
            n
          );
        }
      };
    function P(t) {
      return 'function' == typeof t || '[object Function]' === $.call(t);
    }
    function D(t) {
      var i = (function(t) {
        var i = Number(t);
        return isNaN(i) ? 0 : 0 !== i && isFinite(i) ? (0 < i ? 1 : -1) * Math.floor(Math.abs(i)) : i;
      })(t);
      return Math.min(Math.max(i, 0), T);
    }
    Array.from ||
      (Array.from =
        (($ = Object.prototype.toString),
        (T = Math.pow(2, 53) - 1),
        function(t, i, e) {
          var n = Object(t);
          if (null == t) throw new TypeError('Array.from requires an array-like object - not null or undefined');
          var r,
            o = 1 < arguments.length ? i : void 0;
          if (void 0 !== o) {
            if (!P(o)) throw new TypeError('Array.from: when provided, the second argument must be a function');
            2 < arguments.length && (r = e);
          }
          for (var s, a = D(n.length), h = P(this) ? Object(new this(a)) : new Array(a), u = 0; u < a; )
            (s = n[u]), (h[u] = o ? (void 0 === r ? o(s, u) : o.call(r, s, u)) : s), (u += 1);
          return (h.length = a), h;
        })),
      (t.Hooper = a),
      (t.Icon = v),
      (t.Navigation = x),
      (t.Pagination = w),
      (t.Progress = y),
      (t.Slide = g),
      (t.addonMixin = { inject: ['$hooper'] }),
      (t.default = a),
      Object.defineProperty(t, '__esModule', { value: !0 });
  }),
  'object' == typeof exports && 'undefined' != typeof module
    ? i(exports, require('vue'))
    : 'function' == typeof define && define.amd
    ? define(['exports', 'vue'], i)
    : i(((t = t || self).Hooper = {}), t.Vue);
